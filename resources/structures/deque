
class Stack:
    """
    Stack implemented using a Python list.

    ğŸ”¹ Demonstrates Abstraction: users interact with push/pop instead of directly manipulating the list.
    ğŸ”¹ Can be extended (Inheritance) to add features like max size or logging.
    """

    def __init__(self):
        self._items = []  # ğŸ” Encapsulation: internal list is hidden (prefix underscore)
                          # ğŸ§¬ Attribute: holds the state of the object

    def push(self, item):
        """
        Add an item to the top.

        ğŸ”¹ Instance Method: modifies object state, uses 'self'.
        ğŸ”¹ Encapsulates logic of list append.
        """
        self._items.append(item)

    def pop(self):
        """
        Remove and return the top item.

        ğŸ”¹ Abstraction: user doesnâ€™t see how item is removed.
        ğŸ”¹ Polymorphism: can be overridden in a subclass for safe pop.
        """
        if self.is_empty():
            raise IndexError("Stack is empty")
        return self._items.pop()

    def peek(self):
        """
        Return the top item without removing it.

        ğŸ”¹ Abstraction: shields user from internal indexing logic.
        """
        return self._items[-1] if not self.is_empty() else None

    def is_empty(self):
        """
        Returns True if stack is empty.

        ğŸ”¹ Read-only method: could be marked as a property.
        ğŸ”¹ Encapsulates logic for checking state.
        """
        return len(self._items) == 0

class Queue:
    """
    Queue using a Python list with pop(0) for dequeue (FIFO).

    ğŸ”¹ Demonstrates Abstraction: user doesn't deal with index shifts.
    ğŸ”¹ Inheritance-ready for custom priority queues, etc.
    """

    def __init__(self):
        self._items = []  # ğŸ” Encapsulation: internal data is hidden from the user

    def enqueue(self, item):
        """
        Add item to the rear.

        ğŸ”¹ Method: alters the internal state.
        ğŸ”¹ Encapsulation: controls how elements are added.
        """
        self._items.append(item)

    def dequeue(self):
        """
        Remove and return item from the front.

        ğŸ”¹ Encapsulation: shields pop(0)'s complexity from caller.
        ğŸ”¹ Polymorphic potential: override for performance (use collections.deque).
        """
        if self.is_empty():
            raise IndexError("Queue is empty")
        return self._items.pop(0)

    def is_empty(self):
        """
        Check if queue is empty.

        ğŸ”¹ Simple getter method (could be a @property).
        ğŸ”¹ Encapsulation: user doesn't check _items directly.
        """
        return len(self._items) == 0

class Deque:
    """
    Deque allows insertion and removal from both ends.

    ğŸ”¹ Demonstrates Abstraction: client code uses named methods.
    ğŸ”¹ Inheritance: base for implementing advanced structures (e.g., PalindromeChecker).
    """

    def __init__(self):
        self._items = []  # ğŸ” Encapsulation: hides actual storage implementation

    def add_front(self, item):
        """
        Add item to the front.

        ğŸ”¹ Method: encapsulates list insert(0).
        ğŸ”¹ Abstracts underlying data structure from user.
        """
        self._items.insert(0, item)

    def add_rear(self, item):
        """
        Add item to the rear.

        ğŸ”¹ Abstraction: user just calls a clear method name.
        """
        self._items.append(item)

    def remove_front(self):
        """
        Remove and return front item.

        ğŸ”¹ Polymorphism potential: override to improve performance.
        ğŸ”¹ Encapsulates boundary checking.
        """
        if self.is_empty():
            raise IndexError("Deque is empty")
        return self._items.pop(0)

    def remove_rear(self):
        """
        Remove and return rear item.

        ğŸ”¹ Encapsulation: hides index logic.
        ğŸ”¹ Can be extended to log history (Inheritance).
        """
        if self.is_empty():
            raise IndexError("Deque is empty")
        return self._items.pop()

    def is_empty(self):
        """
        Check if deque is empty.

        ğŸ”¹ Simple getter method.
        ğŸ”¹ Could be turned into a read-only property (@property).
        """
        return len(self._items) == 0


