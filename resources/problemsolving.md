# Notes on  PROBLEM SOLVING and LEARNING

# Practical Learning 

* Start with a problem from Projects or Leetcode.
* Attempt it on your own, using the problem solving guides below
* Struggle for a little bit of time to come up with your own solution to the minimum task, max 15 minutes.
* Look up solution through availale solutions, answers sections, online or AI.
* Study solution until you understand it, documenting ideas, topics, techniques and tools for further reading.
* Research further reading material in books, courses, tutorials and AI. 
* Retry problem, and repeat previous steps until you can solve it on your own. 
* Look into optimizations, improvements and alternative solutions. 
* Look for similar problems and see if solution can be generalized or modified to work on them.
* Document new information in journal and take notes of patterns techniques and tools for future problems.
* Move on as needed.

# PROJECTS

For **Python projects**, focused on  **programming fundamentals, OOP, debugging, and testing**:

## 🧠 **1. Define and Understand the Problem**

*  Identify inputs, outputs, processes, flow, edge cases and constraints .
*  Organize ideas modules, classes, function and variables.
*  Break the problem into minimal sub-tasks.
*  Document all requirements. 

## 📚 **2. Brainstorm**

*  For each sub task brainstorm solutions.
*  Start from what you are given then what you already know and build on that.
*  Brainstorm and note ideas without evaluation.
*  Experiment with what you have and know to see if anything comes up.
*  Try to come up with a solution based off that.


## 📉 **3. Analyze and Organize**

*  Organize thoughts into possible solutions.
*  Research to fill in gaps and get unstuck.
*  Evaluate ideas using criteria like feasibility, complexity, reliability, scalability and efficiency.
*  Consider trade-offs and perform risk assessment.
*  Pick best solution.

## 🏗️ **4. Design and Develop**

* Create detailed designs for modules,  classes, functions and variables.
* Define the program flow from start to end with inputs, processes and outputs.
* Design MVP, prototypes or models as needed.
* Implement each in steps bits and pieces.
* Use version control and design documentation best practices.
* Debug as needed and incrementally build up to the full solution.

## 🧪 **5. Tests and Validate**

* Test against the original requirements and constraints.
* Test Performance and scalability.
* Iterate as necessary to improve performance or reliability.
* Design Tests to automate the process and run tests.
* Work in feedback loop of increaing test coverage and improving the program 
---

## 📦 **6. Refactor Review and Optimize**

* Refactor for readablity, performance, reliability,  scalability and implementing new features.
* Add comments, docstrings type hints and format code.
* Optimize complexity wherever possible.
* Document lessons challenges and future improvements if any.
---


# FOR LEETCODE

## 🔧 **1. Understand the Problem Clearly **

* **Read the full problem statement carefully, three times.**
* Identify and ask questions:
  * **Input format**
  * **Output format**
  * **Constraints**
  * **Edge cases**
  * Go through examples, work them out and understand problem flow.
  * Rephrase problem, remove redundant information, abstract and break problem into tasks.
---

## 📊 **2. Gather Information (Analyze Examples)**

* Identify patterns in inputs/outputs and examples.
* Experiment with other inputs and examples to see what comes up.
*  Start from what you are given then what you already know and build on that.
*  Brainstorm and note ideas without evaluation.
* Ask questions like:
* Existing tools functions and libraries to use.
* Input Validation, size
---

## 🧠 **3. Consider Multiple Approaches 
  * Consider different solution strategies using different data structures, algorithms and patterns.
  * Compare time/space complexity of your ideas.
``* Try:
  * Brute force.
  * Optimize for time.
  * Optimize for space.
  * Ask whats the most important contraints, space or time 
---


### 🏗️ **4. Design and Develop**

*  In solution class develop functions to solve.
* Write clean, modular code.
* Use helper functions if needed.
* Follow naming conventions.
* Use comments for clarity if needed.
* Build incrementally—don’t write everything before testing.

### 🧪 **5. Review Test and Validate**

* Use all provided test cases.
* Add your own:
  * Edge cases   * Corner cases (repeats, unordered input)
* Use print/debug statements or IDE debugger if needed.
* Analyze complexity of solution.

### 📈 **6. Submit Revise, and Document
* Submit the solution.
* Review:
  * Time Complexity.
  * Space Complexity.
  * Compare with other top solutions for learning new tricks.
  * Refactor to improve performance or readability.
  * Document techniques applies and new material learnt.
  